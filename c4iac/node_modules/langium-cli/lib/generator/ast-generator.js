"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAst = void 0;
const langium_1 = require("langium");
const type_system_1 = require("langium/lib/grammar/type-system");
const util_1 = require("./util");
function generateAst(services, grammars, config) {
    const astTypes = (0, type_system_1.collectAst)(services.shared.workspace.LangiumDocuments, grammars);
    const fileNode = new langium_1.CompositeGeneratorNode();
    fileNode.append(util_1.generatedHeader, '/* eslint-disable @typescript-eslint/array-type */', langium_1.NL, '/* eslint-disable @typescript-eslint/no-empty-interface */', langium_1.NL);
    const crossRef = grammars.some(grammar => hasCrossReferences(grammar));
    if (config.langiumInternal) {
        fileNode.append(`import type { AstNode, AstReflection${crossRef ? ', Reference' : ''}, ReferenceInfo, TypeMetaData } from '../../syntax-tree';`, langium_1.NL, "import { isAstNode } from '../../utils/ast-util';", langium_1.NL, langium_1.NL);
    }
    else {
        fileNode.append(`import { AstNode, AstReflection${crossRef ? ', Reference' : ''}, ReferenceInfo, isAstNode, TypeMetaData } from 'langium';`, langium_1.NL, langium_1.NL);
    }
    for (const type of astTypes.unions) {
        fileNode.append(type.toString(), langium_1.NL);
    }
    for (const interfaceType of astTypes.interfaces) {
        fileNode.append(interfaceType.toString(), langium_1.NL);
    }
    astTypes.unions = astTypes.unions.filter(e => e.reflection);
    fileNode.append(generateAstReflection(config, astTypes));
    return (0, langium_1.processGeneratorNode)(fileNode);
}
exports.generateAst = generateAst;
function hasCrossReferences(grammar) {
    return !!(0, langium_1.streamAllContents)(grammar).find(langium_1.GrammarAST.isCrossReference);
}
function generateAstReflection(config, astTypes) {
    const typeNames = astTypes.interfaces.map(t => `'${t.name}'`)
        .concat(astTypes.unions.map(t => `'${t.name}'`))
        .sort();
    const crossReferenceTypes = buildCrossReferenceTypes(astTypes);
    const reflectionNode = new langium_1.CompositeGeneratorNode();
    reflectionNode.append(`export type ${config.projectName}AstType = ${typeNames.join(' | ')};`, langium_1.NL, langium_1.NL, `export class ${config.projectName}AstReflection implements AstReflection {`, langium_1.NL, langium_1.NL);
    reflectionNode.indent(classBody => {
        classBody.append('getAllTypes(): string[] {', langium_1.NL);
        classBody.indent(allTypes => {
            allTypes.append(`return [${typeNames.join(', ')}];`, langium_1.NL);
        });
        classBody.append('}', langium_1.NL, langium_1.NL, 'isInstance(node: unknown, type: string): boolean {', langium_1.NL);
        classBody.indent(isInstance => {
            isInstance.append('return isAstNode(node) && this.isSubtype(node.$type, type);', langium_1.NL);
        });
        classBody.append('}', langium_1.NL, langium_1.NL, 'isSubtype(subtype: string, supertype: string): boolean {', langium_1.NL, buildIsSubtypeMethod(astTypes), '}', langium_1.NL, langium_1.NL, 'getReferenceType(refInfo: ReferenceInfo): string {', langium_1.NL, buildReferenceTypeMethod(crossReferenceTypes), '}', langium_1.NL, langium_1.NL, 'getTypeMetaData(type: string): TypeMetaData {', langium_1.NL, buildTypeMetaDataMethod(astTypes), '}', langium_1.NL);
    });
    reflectionNode.append('}', langium_1.NL, langium_1.NL, `export const reflection = new ${config.projectName}AstReflection();`, langium_1.NL);
    return reflectionNode;
}
function buildTypeMetaDataMethod(astTypes) {
    const typeSwitchNode = new langium_1.IndentNode();
    typeSwitchNode.append('switch (type) {', langium_1.NL);
    typeSwitchNode.indent(caseNode => {
        const allProperties = (0, type_system_1.collectAllProperties)(astTypes.interfaces);
        for (const interfaceType of astTypes.interfaces) {
            const props = allProperties.get(interfaceType.name);
            const arrayProps = props.filter(e => e.typeAlternatives.some(e => e.array));
            const booleanProps = props.filter(e => e.typeAlternatives.every(e => !e.array && e.types.includes('boolean')));
            if (arrayProps.length > 0 || booleanProps.length > 0) {
                caseNode.append(`case '${interfaceType.name}': {`, langium_1.NL);
                caseNode.indent(caseContent => {
                    caseContent.append('return {', langium_1.NL);
                    caseContent.indent(returnType => {
                        returnType.append(`name: '${interfaceType.name}',`, langium_1.NL);
                        returnType.append('mandatory: [', langium_1.NL, buildMandatoryType(arrayProps, booleanProps), ']', langium_1.NL);
                    });
                    caseContent.append('};', langium_1.NL);
                });
                caseNode.append('}', langium_1.NL);
            }
        }
        caseNode.append('default: {', langium_1.NL);
        caseNode.indent(defaultNode => {
            defaultNode.append('return {', langium_1.NL);
            defaultNode.indent(defaultType => {
                defaultType.append('name: type,', langium_1.NL, 'mandatory: []', langium_1.NL);
            });
            defaultNode.append('};', langium_1.NL);
        });
        caseNode.append('}', langium_1.NL);
    });
    typeSwitchNode.append('}', langium_1.NL);
    return typeSwitchNode;
}
function buildMandatoryType(arrayProps, booleanProps) {
    const indent = new langium_1.IndentNode();
    const all = arrayProps.concat(booleanProps).sort((a, b) => a.name.localeCompare(b.name));
    for (let i = 0; i < all.length; i++) {
        const property = all[i];
        const type = arrayProps.includes(property) ? 'array' : 'boolean';
        indent.append("{ name: '", property.name, "', type: '", type, "' }", i < all.length - 1 ? ',' : '', langium_1.NL);
    }
    return indent;
}
function buildReferenceTypeMethod(crossReferenceTypes) {
    const typeSwitchNode = new langium_1.IndentNode();
    typeSwitchNode.append('const referenceId = `${refInfo.container.$type}:${refInfo.property}`;', langium_1.NL);
    typeSwitchNode.append('switch (referenceId) {', langium_1.NL);
    typeSwitchNode.indent(caseNode => {
        for (const crossRef of crossReferenceTypes) {
            caseNode.append(`case '${crossRef.type}:${crossRef.feature}': {`, langium_1.NL);
            caseNode.indent(caseContent => {
                caseContent.append(`return ${crossRef.referenceType};`, langium_1.NL);
            });
            caseNode.append('}', langium_1.NL);
        }
        caseNode.append('default: {', langium_1.NL);
        caseNode.indent(defaultNode => {
            defaultNode.append('throw new Error(`${referenceId} is not a valid reference id.`);', langium_1.NL);
        });
        caseNode.append('}', langium_1.NL);
    });
    typeSwitchNode.append('}', langium_1.NL);
    return typeSwitchNode;
}
function buildCrossReferenceTypes(astTypes) {
    const crossReferences = [];
    for (const typeInterface of astTypes.interfaces) {
        for (const property of typeInterface.properties.sort((a, b) => a.name.localeCompare(b.name))) {
            property.typeAlternatives.filter(e => e.reference).flatMap(e => e.types).forEach(type => crossReferences.push({
                type: typeInterface.name,
                feature: property.name,
                referenceType: type
            }));
        }
    }
    return crossReferences.sort((a, b) => a.type.localeCompare(b.type));
}
function buildIsSubtypeMethod(astTypes) {
    const methodNode = new langium_1.IndentNode();
    methodNode.append('if (subtype === supertype) {', langium_1.NL);
    methodNode.indent(ifNode => {
        ifNode.append('return true;', langium_1.NL);
    });
    methodNode.append('}', langium_1.NL, 'switch (subtype) {', langium_1.NL);
    methodNode.indent(switchNode => {
        const groups = groupBySupertypes(astTypes);
        for (const [superTypes, typeGroup] of groups.entriesGroupedByKey()) {
            for (const typeName of typeGroup) {
                switchNode.append(`case ${typeName}:`, langium_1.NL);
            }
            switchNode.contents.pop();
            switchNode.append(' {', langium_1.NL);
            switchNode.indent(caseNode => {
                caseNode.append(`return ${superTypes.split(':').map(e => `this.isSubtype(${e}, supertype)`).join(' || ')};`);
            });
            switchNode.append(langium_1.NL, '}', langium_1.NL);
        }
        switchNode.append('default: {', langium_1.NL);
        switchNode.indent(defaultNode => {
            defaultNode.append('return false;', langium_1.NL);
        });
        switchNode.append('}', langium_1.NL);
    });
    methodNode.append('}', langium_1.NL);
    return methodNode;
}
function groupBySupertypes(astTypes) {
    const allTypes = astTypes.interfaces
        .concat(astTypes.unions)
        .filter(e => e.superTypes.size > 0);
    const superToChild = new langium_1.MultiMap();
    for (const item of allTypes) {
        superToChild.add([...item.superTypes].join(':'), item.name);
    }
    return superToChild;
}
//# sourceMappingURL=ast-generator.js.map