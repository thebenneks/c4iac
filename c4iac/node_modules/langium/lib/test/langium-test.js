"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectSemanticToken = exports.highlightHelper = exports.clearDocuments = exports.expectWarning = exports.expectError = exports.expectIssue = exports.expectNoIssues = exports.validationHelper = exports.parseDocument = exports.expectFormatting = exports.expectHover = exports.expectFindReferences = exports.expectGoToDefinition = exports.expectCompletion = exports.expectFoldings = exports.expectSymbols = exports.expectFunction = exports.parseHelper = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const regex_util_1 = require("../utils/regex-util");
const grammar_util_1 = require("../utils/grammar-util");
const semantic_token_provider_1 = require("../lsp/semantic-token-provider");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
function parseHelper(services) {
    const metaData = services.LanguageMetaData;
    const documentBuilder = services.shared.workspace.DocumentBuilder;
    return async (input) => {
        const randomNumber = Math.floor(Math.random() * 10000000) + 1000000;
        const uri = vscode_uri_1.URI.parse(`file:///${randomNumber}${metaData.fileExtensions[0]}`);
        const document = services.shared.workspace.LangiumDocumentFactory.fromString(input, uri);
        services.shared.workspace.LangiumDocuments.addDocument(document);
        await documentBuilder.build([document]);
        return document;
    };
}
exports.parseHelper = parseHelper;
let expectedFunction = (actual, expected, message) => {
    if (typeof expect === 'function') {
        if (message && expect.length === 2) {
            // With `jest-expect-message`
            expect(actual, message).toEqual(expected);
        }
        else {
            expect(actual).toEqual(expected);
        }
    }
    else {
        throw new Error('No expect function provided');
    }
};
/**
 * Overrides the assertion function used by tests. Tries to use Jest by default.
 */
function expectFunction(functions) {
    expectedFunction = functions;
}
exports.expectFunction = expectFunction;
function expectSymbols(services) {
    return async (input) => {
        var _a;
        const document = await parseDocument(services, input.text);
        const symbolProvider = services.lsp.DocumentSymbolProvider;
        const symbols = (_a = await (symbolProvider === null || symbolProvider === void 0 ? void 0 : symbolProvider.getSymbols(document, textDocumentParams(document)))) !== null && _a !== void 0 ? _a : [];
        expectedFunction(symbols.length, input.expectedSymbols.length, `Expected ${input.expectedSymbols.length} but found ${symbols.length} symbols in document.`);
        for (let i = 0; i < input.expectedSymbols.length; i++) {
            const expected = input.expectedSymbols[i];
            const item = symbols[i];
            if (typeof expected === 'string') {
                expectedFunction(item.name, expected);
            }
            else {
                expectedFunction(item, expected);
            }
        }
    };
}
exports.expectSymbols = expectSymbols;
function expectFoldings(services) {
    return async (input) => {
        var _a;
        const { output, ranges } = replaceIndices(input);
        const document = await parseDocument(services, output);
        const foldingRangeProvider = services.lsp.FoldingRangeProvider;
        const foldings = (_a = await (foldingRangeProvider === null || foldingRangeProvider === void 0 ? void 0 : foldingRangeProvider.getFoldingRanges(document, textDocumentParams(document)))) !== null && _a !== void 0 ? _a : [];
        foldings.sort((a, b) => a.startLine - b.startLine);
        expectedFunction(foldings.length, ranges.length, `Expected ${ranges.length} but received ${foldings.length} foldings`);
        for (let i = 0; i < ranges.length; i++) {
            const expected = ranges[i];
            const item = foldings[i];
            const expectedStart = document.textDocument.positionAt(expected[0]);
            const expectedEnd = document.textDocument.positionAt(expected[1]);
            expectedFunction(item.startLine, expectedStart.line, `Expected folding start at line ${expectedStart.line} but received folding start at line ${item.startLine} instead.`);
            expectedFunction(item.endLine, expectedEnd.line, `Expected folding end at line ${expectedEnd.line} but received folding end at line ${item.endLine} instead.`);
        }
    };
}
exports.expectFoldings = expectFoldings;
function textDocumentParams(document) {
    return { textDocument: { uri: document.textDocument.uri } };
}
function expectCompletion(services) {
    return async (expectedCompletion) => {
        var _a;
        const { output, indices } = replaceIndices(expectedCompletion);
        const document = await parseDocument(services, output);
        const completionProvider = services.lsp.CompletionProvider;
        const offset = indices[expectedCompletion.index];
        const completions = (_a = await (completionProvider === null || completionProvider === void 0 ? void 0 : completionProvider.getCompletion(document, textDocumentPositionParams(document, offset)))) !== null && _a !== void 0 ? _a : { items: [] };
        const expectedItems = expectedCompletion.expectedItems;
        const items = completions.items.sort((a, b) => { var _a; return ((_a = a.sortText) === null || _a === void 0 ? void 0 : _a.localeCompare(b.sortText || '0')) || 0; });
        expectedFunction(items.length, expectedItems.length, `Expected ${expectedItems.length} but received ${items.length} completion items`);
        for (let i = 0; i < expectedItems.length; i++) {
            const expected = expectedItems[i];
            const completion = items[i];
            if (typeof expected === 'string') {
                expectedFunction(completion.label, expected);
            }
            else {
                expectedFunction(completion, expected);
            }
        }
    };
}
exports.expectCompletion = expectCompletion;
function expectGoToDefinition(services) {
    return async (expectedGoToDefinition) => {
        var _a;
        const { output, indices, ranges } = replaceIndices(expectedGoToDefinition);
        const document = await parseDocument(services, output);
        const definitionProvider = services.lsp.DefinitionProvider;
        const locationLinks = (_a = await (definitionProvider === null || definitionProvider === void 0 ? void 0 : definitionProvider.getDefinition(document, textDocumentPositionParams(document, indices[expectedGoToDefinition.index])))) !== null && _a !== void 0 ? _a : [];
        const expectedRange = {
            start: document.textDocument.positionAt(ranges[expectedGoToDefinition.rangeIndex][0]),
            end: document.textDocument.positionAt(ranges[expectedGoToDefinition.rangeIndex][1])
        };
        expectedFunction(locationLinks.length, 1, `Expected a single definition but received ${locationLinks.length}`);
        const range = locationLinks[0].targetSelectionRange;
        expectedFunction(range, expectedRange, `Expected range ${rangeToString(expectedRange)} does not match actual range ${rangeToString(range)}`);
    };
}
exports.expectGoToDefinition = expectGoToDefinition;
function expectFindReferences(services) {
    return async (expectedFindReferences) => {
        var _a;
        const { output, indices, ranges } = replaceIndices(expectedFindReferences);
        const document = await parseDocument(services, output);
        const expectedRanges = ranges.map(range => ({
            start: document.textDocument.positionAt(range[0]),
            end: document.textDocument.positionAt(range[1])
        }));
        const referenceFinder = services.lsp.ReferencesProvider;
        for (const index of indices) {
            const referenceParameters = referenceParams(document, index, expectedFindReferences.includeDeclaration);
            const references = (_a = await (referenceFinder === null || referenceFinder === void 0 ? void 0 : referenceFinder.findReferences(document, referenceParameters))) !== null && _a !== void 0 ? _a : [];
            expectedFunction(references.length, expectedRanges.length, 'Found references do not match amount of expected references');
            for (const reference of references) {
                expectedFunction(expectedRanges.some(range => isRangeEqual(range, reference.range)), true, `Found unexpected reference at range ${rangeToString(reference.range)}`);
            }
        }
        clearDocuments(services);
    };
}
exports.expectFindReferences = expectFindReferences;
function referenceParams(document, offset, includeDeclaration) {
    return {
        textDocument: { uri: document.textDocument.uri },
        position: document.textDocument.positionAt(offset),
        context: { includeDeclaration }
    };
}
function expectHover(services) {
    return async (expectedHover) => {
        const { output, indices } = replaceIndices(expectedHover);
        const document = await parseDocument(services, output);
        const hoverProvider = services.lsp.HoverProvider;
        const hover = await (hoverProvider === null || hoverProvider === void 0 ? void 0 : hoverProvider.getHoverContent(document, textDocumentPositionParams(document, indices[expectedHover.index])));
        const hoverContent = hover && vscode_languageserver_1.MarkupContent.is(hover.contents) ? hover.contents.value : undefined;
        expectedFunction(hoverContent, expectedHover.hover);
    };
}
exports.expectHover = expectHover;
function expectFormatting(services) {
    const formatter = services.lsp.Formatter;
    if (!formatter) {
        throw new Error(`No formatter registered for language ${services.LanguageMetaData.languageId}`);
    }
    return async (expectedFormatting) => {
        var _a;
        const document = await parseDocument(services, expectedFormatting.before);
        const identifier = { uri: document.uri.toString() };
        const options = (_a = expectedFormatting.options) !== null && _a !== void 0 ? _a : {
            insertSpaces: true,
            tabSize: 4
        };
        const edits = await (expectedFormatting.range ?
            formatter.formatDocumentRange(document, { options, textDocument: identifier, range: expectedFormatting.range }) :
            formatter.formatDocument(document, { options, textDocument: identifier }));
        const editedDocument = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document.textDocument, edits);
        expectedFunction(editedDocument, expectedFormatting.after);
    };
}
exports.expectFormatting = expectFormatting;
function textDocumentPositionParams(document, offset) {
    return { textDocument: { uri: document.textDocument.uri }, position: document.textDocument.positionAt(offset) };
}
async function parseDocument(services, input) {
    const document = await parseHelper(services)(input);
    if (!document.parseResult) {
        throw new Error('Could not parse document');
    }
    return document;
}
exports.parseDocument = parseDocument;
function replaceIndices(base) {
    const indices = [];
    const ranges = [];
    const rangeStack = [];
    const indexMarker = base.indexMarker || '<|>';
    const rangeStartMarker = base.rangeStartMarker || '<|';
    const rangeEndMarker = base.rangeEndMarker || '|>';
    const regex = new RegExp(`${(0, regex_util_1.escapeRegExp)(indexMarker)}|${(0, regex_util_1.escapeRegExp)(rangeStartMarker)}|${(0, regex_util_1.escapeRegExp)(rangeEndMarker)}`);
    let matched = true;
    let input = base.text;
    while (matched) {
        const regexMatch = regex.exec(input);
        if (regexMatch) {
            const matchedString = regexMatch[0];
            switch (matchedString) {
                case indexMarker:
                    indices.push(regexMatch.index);
                    break;
                case rangeStartMarker:
                    rangeStack.push(regexMatch.index);
                    break;
                case rangeEndMarker: {
                    const rangeStart = rangeStack.pop() || 0;
                    ranges.push([rangeStart, regexMatch.index]);
                    break;
                }
            }
            input = input.substring(0, regexMatch.index) + input.substring(regexMatch.index + matchedString.length);
        }
        else {
            matched = false;
        }
    }
    return { output: input, indices, ranges: ranges.sort((a, b) => a[0] - b[0]) };
}
function validationHelper(services) {
    const parse = parseHelper(services);
    return async (input) => {
        const document = await parse(input);
        return { document, diagnostics: await services.validation.DocumentValidator.validateDocument(document) };
    };
}
exports.validationHelper = validationHelper;
function isRangeEqual(lhs, rhs) {
    return lhs.start.character === rhs.start.character
        && lhs.start.line === rhs.start.line
        && lhs.end.character === rhs.end.character
        && lhs.end.line === rhs.end.line;
}
function rangeToString(range) {
    return `${range.start.line}:${range.start.character}--${range.end.line}:${range.end.character}`;
}
function filterByOptions(validationResult, options) {
    var _a;
    const filters = [];
    if ('node' in options) {
        const cstNode = options.property
            ? (0, grammar_util_1.findNodeForProperty)((_a = options.node) === null || _a === void 0 ? void 0 : _a.$cstNode, options.property.name, options.property.index)
            : options.node.$cstNode;
        if (!cstNode) {
            throw new Error('Cannot find the node!');
        }
        filters.push(d => isRangeEqual(cstNode.range, d.range));
    }
    if ('offset' in options) {
        const outer = {
            start: validationResult.document.textDocument.positionAt(options.offset),
            end: validationResult.document.textDocument.positionAt(options.offset + options.length)
        };
        filters.push(d => isRangeEqual(outer, d.range));
    }
    if ('range' in options) {
        filters.push(d => isRangeEqual(options.range, d.range));
    }
    if (options.code) {
        filters.push(d => d.code === options.code);
    }
    if (options.message) {
        if (typeof options.message === 'string') {
            filters.push(d => d.message === options.message);
        }
        else if (options.message instanceof RegExp) {
            const regexp = options.message;
            filters.push(d => regexp.test(d.message));
        }
    }
    if (options.severity) {
        filters.push(d => d.severity === options.severity);
    }
    return validationResult.diagnostics.filter(diag => filters.every(holdsFor => holdsFor(diag)));
}
function expectNoIssues(validationResult, filterOptions) {
    const filtered = filterOptions ? filterByOptions(validationResult, filterOptions) : validationResult.diagnostics;
    expectedFunction(filtered.length, 0, `Expected no issues, but found ${filtered.length}`);
}
exports.expectNoIssues = expectNoIssues;
function expectIssue(validationResult, filterOptions) {
    const filtered = filterOptions ? filterByOptions(validationResult, filterOptions) : validationResult.diagnostics;
    expectedFunction(filtered.length > 0, true, 'Found no issues');
}
exports.expectIssue = expectIssue;
function expectError(validationResult, message, filterOptions) {
    const content = {
        message,
        severity: vscode_languageserver_1.DiagnosticSeverity.Error
    };
    expectIssue(validationResult, Object.assign(Object.assign({}, filterOptions), content));
}
exports.expectError = expectError;
function expectWarning(validationResult, message, filterOptions) {
    const content = {
        message,
        severity: vscode_languageserver_1.DiagnosticSeverity.Warning
    };
    expectIssue(validationResult, Object.assign(Object.assign({}, filterOptions), content));
}
exports.expectWarning = expectWarning;
function clearDocuments(services) {
    const allDocs = services.shared.workspace.LangiumDocuments.all.map(x => x.uri).toArray();
    services.shared.workspace.DocumentBuilder.update([], allDocs);
}
exports.clearDocuments = clearDocuments;
function highlightHelper(services) {
    const parse = parseHelper(services);
    const tokenProvider = services.lsp.SemanticTokenProvider;
    return async (text) => {
        const { output: input, ranges } = replaceIndices({
            text
        });
        const document = await parse(input);
        const params = { textDocument: { uri: document.textDocument.uri } };
        const tokens = tokenProvider.semanticHighlight(document, params, new vscode_languageserver_1.CancellationTokenSource().token);
        return { tokens: semantic_token_provider_1.SemanticTokensDecoder.decode(tokens, document), ranges };
    };
}
exports.highlightHelper = highlightHelper;
function expectSemanticToken(tokensWithRanges, options) {
    const range = tokensWithRanges.ranges[options.rangeIndex || 0];
    const result = tokensWithRanges.tokens.filter(t => {
        return t.tokenType === options.tokenType && t.offset === range[0] && t.offset + t.text.length === range[1];
    });
    expectedFunction(result.length, 1, `Expected one token with the specified options but found ${result.length}`);
}
exports.expectSemanticToken = expectSemanticToken;
//# sourceMappingURL=langium-test.js.map