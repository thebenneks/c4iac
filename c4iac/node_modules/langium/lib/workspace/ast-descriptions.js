"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultReferenceDescriptionProvider = exports.DefaultAstNodeDescriptionProvider = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const ast_util_1 = require("../utils/ast-util");
const cst_util_1 = require("../utils/cst-util");
const promise_util_1 = require("../utils/promise-util");
const uri_util_1 = require("../utils/uri-util");
class DefaultAstNodeDescriptionProvider {
    constructor(services) {
        this.astNodeLocator = services.workspace.AstNodeLocator;
    }
    createDescription(node, name, document = (0, ast_util_1.getDocument)(node)) {
        return {
            node,
            name,
            type: node.$type,
            documentUri: document.uri,
            path: this.astNodeLocator.getAstNodePath(node)
        };
    }
    /**
     * @deprecated This method has been moved to the `ScopeComputation` service and renamed to `computeExports`.
     */
    createDescriptions() {
        throw new Error('Deprecated: This method has been moved to the `ScopeComputation` service and renamed to `computeExports`.');
    }
}
exports.DefaultAstNodeDescriptionProvider = DefaultAstNodeDescriptionProvider;
class DefaultReferenceDescriptionProvider {
    constructor(services) {
        this.nodeLocator = services.workspace.AstNodeLocator;
    }
    async createDescriptions(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const descr = [];
        const rootNode = document.parseResult.value;
        for (const astNode of (0, ast_util_1.streamAst)(rootNode)) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            (0, ast_util_1.streamReferences)(astNode).filter(refInfo => !(0, ast_util_1.isLinkingError)(refInfo)).forEach(refInfo => {
                const targetNodeDesc = refInfo.reference.$nodeDescription;
                // Do not handle not yet linked references.
                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked
                if (targetNodeDesc) {
                    descr.push(this.createDescription(refInfo, targetNodeDesc));
                }
            });
        }
        return descr;
    }
    createDescription(refInfo, targetNodeDescr) {
        const docUri = (0, ast_util_1.getDocument)(refInfo.container).uri;
        const refCstNode = refInfo.reference.$refNode;
        return {
            sourceUri: docUri,
            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),
            targetUri: targetNodeDescr.documentUri,
            targetPath: targetNodeDescr.path,
            segment: (0, cst_util_1.toDocumentSegment)(refCstNode),
            local: (0, uri_util_1.equalURI)(targetNodeDescr.documentUri, docUri)
        };
    }
}
exports.DefaultReferenceDescriptionProvider = DefaultReferenceDescriptionProvider;
//# sourceMappingURL=ast-descriptions.js.map