"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultIndexManager = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const ast_util_1 = require("../utils/ast-util");
const stream_1 = require("../utils/stream");
const uri_util_1 = require("../utils/uri-util");
const documents_1 = require("./documents");
class DefaultIndexManager {
    constructor(services) {
        this.simpleIndex = new Map();
        this.referenceIndex = new Map();
        this.globalScopeCache = new Map();
        this.serviceRegistry = services.ServiceRegistry;
        this.astReflection = services.AstReflection;
        this.langiumDocuments = () => services.workspace.LangiumDocuments;
    }
    findAllReferences(targetNode, astNodePath) {
        const targetDocUri = (0, ast_util_1.getDocument)(targetNode).uri;
        const result = [];
        this.referenceIndex.forEach((docRefs) => {
            docRefs.forEach((refDescr) => {
                if ((0, uri_util_1.equalURI)(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {
                    result.push(refDescr);
                }
            });
        });
        return (0, stream_1.stream)(result);
    }
    allElements(nodeType = '') {
        if (!this.globalScopeCache.has('')) {
            this.globalScopeCache.set('', Array.from(this.simpleIndex.values()).flat());
        }
        const cached = this.globalScopeCache.get(nodeType);
        if (cached) {
            return (0, stream_1.stream)(cached);
        }
        else {
            const elements = this.globalScopeCache.get('').filter(e => this.astReflection.isSubtype(e.type, nodeType));
            this.globalScopeCache.set(nodeType, elements);
            return (0, stream_1.stream)(elements);
        }
    }
    remove(uris) {
        for (const uri of uris) {
            const uriString = uri.toString();
            this.simpleIndex.delete(uriString);
            this.referenceIndex.delete(uriString);
        }
    }
    async updateContent(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.globalScopeCache.clear();
        const services = this.serviceRegistry.getServices(document.uri);
        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);
        for (const data of exports) {
            data.node = undefined; // clear reference to the AST Node
        }
        this.simpleIndex.set(document.uri.toString(), exports);
        document.state = documents_1.DocumentState.IndexedContent;
    }
    async updateReferences(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const services = this.serviceRegistry.getServices(document.uri);
        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);
        this.referenceIndex.set(document.uri.toString(), indexData);
        document.state = documents_1.DocumentState.IndexedReferences;
    }
    getAffectedDocuments(uris) {
        return this.langiumDocuments().all.filter(e => {
            if (uris.some(uri => (0, uri_util_1.equalURI)(e.uri, uri))) {
                return false;
            }
            for (const uri of uris) {
                if (this.isAffected(e, uri)) {
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * Determine whether the given document could be affected by a change of the document
     * identified by the given URI (second parameter).
     */
    isAffected(document, changed) {
        // Cache the uri string
        const changedUriString = changed.toString();
        const documentUri = document.uri.toString();
        // The document is affected if it contains linking errors
        if (document.references.some(e => e.error !== undefined)) {
            return true;
        }
        const references = this.referenceIndex.get(documentUri);
        // ...or if it contains a reference to the changed file
        if (references) {
            return references.filter(e => !e.local).some(e => (0, uri_util_1.equalURI)(e.targetUri, changedUriString));
        }
        return false;
    }
}
exports.DefaultIndexManager = DefaultIndexManager;
//# sourceMappingURL=index-manager.js.map