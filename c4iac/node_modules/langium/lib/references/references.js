"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultReferences = void 0;
const grammar_util_1 = require("../utils/grammar-util");
const ast_util_1 = require("../utils/ast-util");
const cst_util_1 = require("../utils/cst-util");
const stream_1 = require("../utils/stream");
const uri_util_1 = require("../utils/uri-util");
class DefaultReferences {
    constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.index = services.shared.workspace.IndexManager;
        this.nodeLocator = services.workspace.AstNodeLocator;
    }
    findDeclaration(sourceCstNode) {
        if (sourceCstNode) {
            const assignment = (0, grammar_util_1.findAssignment)(sourceCstNode);
            const nodeElem = sourceCstNode.element;
            if (assignment && nodeElem) {
                const reference = nodeElem[assignment.feature];
                if ((0, ast_util_1.isReference)(reference)) {
                    return reference.ref;
                }
                else if (Array.isArray(reference)) {
                    for (const ref of reference) {
                        if ((0, ast_util_1.isReference)(ref)
                            && ref.$refNode.offset <= sourceCstNode.offset
                            && ref.$refNode.end >= sourceCstNode.end) {
                            return ref.ref;
                        }
                    }
                }
                else {
                    return nodeElem;
                }
            }
        }
        return undefined;
    }
    findDeclarationNode(sourceCstNode) {
        const astNode = this.findDeclaration(sourceCstNode);
        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {
            const targetNode = this.nameProvider.getNameNode(astNode);
            if (!targetNode) {
                return astNode.$cstNode;
            }
            else {
                return targetNode;
            }
        }
        return undefined;
    }
    findReferences(targetNode, options) {
        if (options.onlyLocal) {
            return this.findLocalReferences(targetNode, options.includeDeclaration);
        }
        else {
            return this.findGlobalReferences(targetNode, options.includeDeclaration);
        }
    }
    findGlobalReferences(targetNode, includeDeclaration = false) {
        const refs = [];
        if (includeDeclaration) {
            const ref = this.getReferenceToSelf(targetNode);
            if (ref) {
                refs.push(ref);
            }
        }
        refs.push(...this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode)));
        return (0, stream_1.stream)(refs);
    }
    findLocalReferences(targetNode, includeDeclaration = false) {
        const doc = (0, ast_util_1.getDocument)(targetNode);
        const rootNode = doc.parseResult.value;
        const refs = [];
        if (includeDeclaration) {
            const ref = this.getReferenceToSelf(targetNode);
            if (ref) {
                refs.push(ref);
            }
        }
        const localReferences = [];
        (0, ast_util_1.streamAst)(rootNode).forEach(node => {
            (0, ast_util_1.streamReferences)(node).forEach(refInfo => {
                if (refInfo.reference.ref === targetNode) {
                    localReferences.push(refInfo.reference);
                }
            });
        });
        localReferences.forEach(ref => {
            refs.push({
                sourceUri: (0, ast_util_1.getDocument)(ref.$refNode.element).uri,
                sourcePath: this.nodeLocator.getAstNodePath(ref.$refNode.element),
                targetUri: (0, ast_util_1.getDocument)(targetNode).uri,
                targetPath: this.nodeLocator.getAstNodePath(targetNode),
                segment: (0, cst_util_1.toDocumentSegment)(ref.$refNode),
                local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(ref.$refNode.element).uri, (0, ast_util_1.getDocument)(targetNode).uri)
            });
        });
        return (0, stream_1.stream)(refs);
    }
    getReferenceToSelf(targetNode) {
        const nameNode = this.nameProvider.getNameNode(targetNode);
        if (nameNode) {
            const doc = (0, ast_util_1.getDocument)(targetNode);
            const path = this.nodeLocator.getAstNodePath(targetNode);
            return {
                sourceUri: doc.uri,
                sourcePath: path,
                targetUri: doc.uri,
                targetPath: path,
                segment: (0, cst_util_1.toDocumentSegment)(nameNode),
                local: true
            };
        }
        return undefined;
    }
}
exports.DefaultReferences = DefaultReferences;
//# sourceMappingURL=references.js.map