"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectDeclaredTypes = void 0;
const internal_grammar_util_1 = require("../internal-grammar-util");
const types_util_1 = require("./types-util");
const collections_1 = require("../../utils/collections");
function collectDeclaredTypes(interfaces, types, inferredTypes) {
    var _a;
    function addSuperTypes(child, types) {
        var _a;
        const childType = (_a = types.unions.find(e => e.name === child)) !== null && _a !== void 0 ? _a : types.interfaces.find(e => e.name === child);
        if (childType) {
            childToSuper.get(child).forEach(e => childType.superTypes.add(e));
        }
    }
    const declaredTypes = { unions: [], interfaces: [] };
    // add interfaces
    for (const interfaceType of interfaces) {
        const superTypes = interfaceType.superTypes.filter(e => e.ref).map(e => (0, internal_grammar_util_1.getTypeName)(e.ref));
        const properties = interfaceType.attributes.map(e => ({
            name: e.name,
            optional: e.isOptional === true,
            typeAlternatives: e.typeAlternatives.map(atomTypeToPropertyType)
        }));
        declaredTypes.interfaces.push(new types_util_1.InterfaceType(interfaceType.name, superTypes, properties));
    }
    // add types
    const childToSuper = new collections_1.MultiMap();
    for (const type of types) {
        const alternatives = type.typeAlternatives.map(atomTypeToPropertyType);
        const reflection = type.typeAlternatives.length > 1 && type.typeAlternatives.some(e => { var _a; return ((_a = e.refType) === null || _a === void 0 ? void 0 : _a.ref) !== undefined; });
        declaredTypes.unions.push(new types_util_1.UnionType(type.name, alternatives, { reflection }));
        if (reflection) {
            for (const maybeRef of type.typeAlternatives) {
                if ((_a = maybeRef.refType) === null || _a === void 0 ? void 0 : _a.ref) {
                    childToSuper.add((0, internal_grammar_util_1.getTypeName)(maybeRef.refType.ref), type.name);
                }
            }
        }
    }
    for (const child of childToSuper.keys()) {
        addSuperTypes(child, inferredTypes);
        addSuperTypes(child, declaredTypes);
    }
    return declaredTypes;
}
exports.collectDeclaredTypes = collectDeclaredTypes;
function atomTypeToPropertyType(type) {
    var _a, _b;
    let types = [];
    if (type.refType) {
        types = [type.refType.ref ? (0, internal_grammar_util_1.getTypeName)(type.refType.ref) : type.refType.$refText];
    }
    else {
        types = [(_a = type.primitiveType) !== null && _a !== void 0 ? _a : `'${(_b = type.keywordType) === null || _b === void 0 ? void 0 : _b.value}'`];
    }
    return { types, reference: type.isRef === true, array: type.isArray === true };
}
//# sourceMappingURL=declared-types.js.map