"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectSuperTypes = exports.collectChildrenTypes = exports.typePropertyToString = exports.distinctAndSorted = exports.propertyTypeArrayToString = exports.collectAllAstResources = exports.collectAllProperties = exports.TypeResolutionError = exports.InterfaceType = exports.UnionType = void 0;
const generator_node_1 = require("../../generator/generator-node");
const node_processor_1 = require("../../generator/node-processor");
const ast_util_1 = require("../../utils/ast-util");
const collections_1 = require("../../utils/collections");
const ast_1 = require("../generated/ast");
const internal_grammar_util_1 = require("../internal-grammar-util");
class UnionType {
    constructor(name, union, options) {
        var _a;
        this.superTypes = new Set();
        this.name = name;
        this.union = union;
        this.reflection = (_a = options === null || options === void 0 ? void 0 : options.reflection) !== null && _a !== void 0 ? _a : false;
    }
    toString() {
        const typeNode = new generator_node_1.CompositeGeneratorNode();
        typeNode.contents.push(`export type ${this.name} = ${propertyTypeArrayToString(this.union)};`, generator_node_1.NL);
        if (this.reflection)
            pushReflectionInfo(this.name, typeNode);
        return (0, node_processor_1.processGeneratorNode)(typeNode);
    }
}
exports.UnionType = UnionType;
class InterfaceType {
    constructor(name, superTypes, properties) {
        this.superTypes = new Set();
        this.interfaceSuperTypes = [];
        this.subTypes = new Set();
        this.containerTypes = new Set();
        this.name = name;
        this.superTypes = new Set(superTypes);
        this.interfaceSuperTypes = [...superTypes];
        this.properties = properties;
    }
    toString() {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const superTypes = this.interfaceSuperTypes.length > 0 ? distinctAndSorted([...this.interfaceSuperTypes]) : ['AstNode'];
        interfaceNode.contents.push(`export interface ${this.name} extends ${superTypes.join(', ')} {`, generator_node_1.NL);
        const propertiesNode = new generator_node_1.IndentNode();
        if (this.containerTypes.size > 0) {
            propertiesNode.contents.push(`readonly $container: ${distinctAndSorted([...this.containerTypes]).join(' | ')};`, generator_node_1.NL);
        }
        for (const property of distinctAndSorted(this.properties, (a, b) => a.name.localeCompare(b.name))) {
            const optional = property.optional && !property.typeAlternatives.some(e => e.array) && !property.typeAlternatives.every(e => e.types.length === 1 && e.types[0] === 'boolean') ? '?' : '';
            const type = propertyTypeArrayToString(property.typeAlternatives);
            propertiesNode.contents.push(`${property.name}${optional}: ${type}`, generator_node_1.NL);
        }
        interfaceNode.contents.push(propertiesNode, '}', generator_node_1.NL);
        pushReflectionInfo(this.name, interfaceNode);
        return (0, node_processor_1.processGeneratorNode)(interfaceNode);
    }
}
exports.InterfaceType = InterfaceType;
class TypeResolutionError extends Error {
    constructor(message, target) {
        super(message);
        this.name = 'TypeResolutionError';
        this.target = target;
    }
}
exports.TypeResolutionError = TypeResolutionError;
/**
 * Collects all properties of all interface types. Includes super type properties.
 * @param interfaces A topologically sorted array of interfaces.
 */
function collectAllProperties(interfaces) {
    const map = new collections_1.MultiMap();
    for (const interfaceType of interfaces) {
        map.addAll(interfaceType.name, interfaceType.properties);
    }
    for (const interfaceType of interfaces) {
        for (const superType of interfaceType.interfaceSuperTypes) {
            const superTypeProperties = map.get(superType);
            if (superTypeProperties) {
                map.addAll(interfaceType.name, superTypeProperties);
            }
        }
    }
    return map;
}
exports.collectAllProperties = collectAllProperties;
function collectAllAstResources(grammars, documents, visited = new Set(), astResources = { parserRules: new Set(), datatypeRules: new Set(), interfaces: new Set(), types: new Set() }) {
    for (const grammar of grammars) {
        const doc = (0, ast_util_1.getDocument)(grammar);
        if (visited.has(doc.uri)) {
            continue;
        }
        visited.add(doc.uri);
        for (const rule of grammar.rules) {
            if ((0, ast_1.isParserRule)(rule) && !rule.fragment) {
                if ((0, internal_grammar_util_1.isDataTypeRule)(rule)) {
                    astResources.datatypeRules.add(rule);
                }
                else {
                    astResources.parserRules.add(rule);
                }
            }
        }
        grammar.interfaces.forEach(e => astResources.interfaces.add(e));
        grammar.types.forEach(e => astResources.types.add(e));
        if (documents) {
            const importedGrammars = grammar.imports.map(e => (0, internal_grammar_util_1.resolveImport)(documents, e));
            collectAllAstResources(importedGrammars, documents, visited, astResources);
        }
    }
    return astResources;
}
exports.collectAllAstResources = collectAllAstResources;
function propertyTypeArrayToString(alternatives) {
    return distinctAndSorted(alternatives.map(typePropertyToString)).join(' | ');
}
exports.propertyTypeArrayToString = propertyTypeArrayToString;
function distinctAndSorted(list, compareFn) {
    return Array.from(new Set(list)).sort(compareFn);
}
exports.distinctAndSorted = distinctAndSorted;
function typePropertyToString(propertyType) {
    let res = distinctAndSorted(propertyType.types).join(' | ');
    res = propertyType.reference ? `Reference<${res}>` : res;
    res = propertyType.array ? `Array<${res}>` : res;
    return res;
}
exports.typePropertyToString = typePropertyToString;
function pushReflectionInfo(name, node) {
    node.contents.push(generator_node_1.NL, `export const ${name} = '${name}';`, generator_node_1.NL, generator_node_1.NL);
    node.contents.push(`export function is${name}(item: unknown): item is ${name} {`, generator_node_1.NL);
    const methodBody = new generator_node_1.IndentNode();
    methodBody.contents.push(`return reflection.isInstance(item, ${name});`, generator_node_1.NL);
    node.contents.push(methodBody, '}', generator_node_1.NL);
}
function collectChildrenTypes(interfaceNode, references, langiumDocuments, nodeLocator) {
    const childrenTypes = new Set();
    childrenTypes.add(interfaceNode);
    const refs = references.findReferences(interfaceNode, {});
    refs.forEach(ref => {
        const doc = langiumDocuments.getOrCreateDocument(ref.sourceUri);
        const astNode = nodeLocator.getAstNode(doc, ref.sourcePath);
        if ((0, ast_1.isInterface)(astNode)) {
            childrenTypes.add(astNode);
            const childrenOfInterface = collectChildrenTypes(astNode, references, langiumDocuments, nodeLocator);
            childrenOfInterface.forEach(child => childrenTypes.add(child));
        }
        else if (astNode && (0, ast_1.isType)(astNode.$container)) {
            childrenTypes.add(astNode.$container);
        }
    });
    return childrenTypes;
}
exports.collectChildrenTypes = collectChildrenTypes;
function collectSuperTypes(ruleNode) {
    const superTypes = new Set();
    if ((0, ast_1.isInterface)(ruleNode)) {
        superTypes.add(ruleNode);
        ruleNode.superTypes.forEach(superType => {
            if ((0, ast_1.isInterface)(superType.ref)) {
                superTypes.add(superType.ref);
                const collectedSuperTypes = collectSuperTypes(superType.ref);
                for (const superType of collectedSuperTypes) {
                    superTypes.add(superType);
                }
            }
        });
    }
    else if ((0, ast_1.isType)(ruleNode)) {
        ruleNode.typeAlternatives.forEach(typeAlternative => {
            var _a;
            if ((_a = typeAlternative.refType) === null || _a === void 0 ? void 0 : _a.ref) {
                if ((0, ast_1.isInterface)(typeAlternative.refType.ref) || (0, ast_1.isType)(typeAlternative.refType.ref)) {
                    const collectedSuperTypes = collectSuperTypes(typeAlternative.refType.ref);
                    for (const superType of collectedSuperTypes) {
                        superTypes.add(superType);
                    }
                }
            }
        });
    }
    return superTypes;
}
exports.collectSuperTypes = collectSuperTypes;
//# sourceMappingURL=types-util.js.map