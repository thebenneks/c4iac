"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAllInterfaces = exports.collectValidationResources = exports.applyErrorToAssignment = exports.validateTypesConsistency = void 0;
const collections_1 = require("../../utils/collections");
const declared_types_1 = require("./declared-types");
const inferred_types_1 = require("./inferred-types");
const types_util_1 = require("./types-util");
const stream_1 = require("../../utils/stream");
const internal_grammar_util_1 = require("../internal-grammar-util");
function validateTypesConsistency(grammar, accept) {
    function applyErrorToRuleNodes(nodes, typeName) {
        return (errorMessage) => {
            nodes.forEach(node => accept('error', errorMessage + ` in a rule that returns type '${typeName}'.`, { node: (node === null || node === void 0 ? void 0 : node.inferredType) ? node.inferredType : node, property: 'name' }));
        };
    }
    // Report missing assignments for required properties in offending nodes
    function applyMissingAssignmentErrorToRuleNodes(nodes, typeName) {
        return (propertyName, errorMessage) => {
            nodes.forEach(node => {
                const assignments = (0, internal_grammar_util_1.extractAssignments)(node.definition);
                if (assignments.find(a => a.feature === propertyName) === undefined) {
                    accept('error', errorMessage + ` in rule '${node.name}', but is required in type '${typeName}'.`, { node, property: 'parameters' });
                }
            });
        };
    }
    const validationResources = collectValidationResources(grammar);
    const propertyMap = new collections_1.MultiMap();
    for (const [typeName, typeInfo] of validationResources.entries()) {
        if ('declared' in typeInfo && isInterface(typeInfo.declared)) {
            propertyMap.addAll(typeName, collectAllSuperProperties(typeInfo.declared, 'declared', validationResources).values());
        }
    }
    for (const [typeName, typeInfo] of validationResources.entries()) {
        if ('declared' in typeInfo) {
            checkConsistentlyDeclaredType(typeInfo, propertyMap, accept);
        }
        if (!isInferredAndDeclared(typeInfo))
            continue;
        const errorToRuleNodes = applyErrorToRuleNodes(typeInfo.nodes, typeName);
        const errorToInvalidRuleNodes = applyMissingAssignmentErrorToRuleNodes(typeInfo.nodes, typeName);
        const errorToAssignment = applyErrorToAssignment(typeInfo.nodes, accept);
        if (isType(typeInfo.inferred) && isType(typeInfo.declared)) {
            checkAlternativesConsistency(typeInfo.inferred.union, typeInfo.declared.union, errorToRuleNodes);
        }
        else if (isInterface(typeInfo.inferred) && isInterface(typeInfo.declared)) {
            const inferredProps = collectAllSuperProperties(typeInfo.inferred, 'inferred', validationResources);
            const declaredProps = collectAllSuperProperties(typeInfo.declared, 'declared', validationResources);
            checkPropertiesConsistency(inferredProps, declaredProps, errorToRuleNodes, errorToAssignment, errorToInvalidRuleNodes);
        }
        else {
            const specificError = `Inferred and declared versions of type ${typeName} both have to be interfaces or unions.`;
            typeInfo.nodes.forEach(node => accept('error', specificError, { node: (node === null || node === void 0 ? void 0 : node.inferredType) ? node.inferredType : node, property: 'name' }));
            accept('error', specificError, { node: typeInfo.node, property: 'name' });
        }
    }
}
exports.validateTypesConsistency = validateTypesConsistency;
function checkConsistentlyDeclaredType(declaredInfo, properties, accept) {
    const declaredType = declaredInfo.declared;
    if (!isInterface(declaredType)) {
        return;
    }
    const allSuperTypes = declaredType.interfaceSuperTypes;
    for (let i = 0; i < allSuperTypes.length; i++) {
        for (let j = i + 1; j < allSuperTypes.length; j++) {
            const outerType = allSuperTypes[i];
            const innerType = allSuperTypes[j];
            const outerProps = properties.get(outerType);
            const innerProps = properties.get(innerType);
            const nonIdentical = getNonIdenticalProps(outerProps, innerProps);
            if (nonIdentical.length > 0) {
                accept('error', `Cannot simultaneously inherit from '${outerType}' and '${innerType}'. Their ${nonIdentical.map(e => "'" + e + "'").join(', ')} properties are not identical.`, {
                    node: declaredInfo.node,
                    property: 'name'
                });
            }
        }
    }
    const allSuperProps = new Set();
    for (const superType of allSuperTypes) {
        const props = properties.get(superType);
        for (const prop of props) {
            allSuperProps.add(prop.name);
        }
    }
    for (const ownProp of declaredType.properties) {
        if (allSuperProps.has(ownProp.name)) {
            const interfaceNode = declaredInfo.node;
            const propNode = interfaceNode.attributes.find(e => e.name === ownProp.name);
            if (propNode) {
                accept('error', `Cannot redeclare property '${ownProp.name}'. It is already inherited from another interface.`, {
                    node: propNode,
                    property: 'name'
                });
            }
        }
    }
}
function getNonIdenticalProps(a, b) {
    const nonIdentical = [];
    for (const outerProp of a) {
        const innerProp = b.find(e => e.name === outerProp.name);
        if (innerProp && !arePropTypesIdentical(outerProp, innerProp)) {
            nonIdentical.push(outerProp.name);
        }
    }
    return nonIdentical;
}
function arePropTypesIdentical(a, b) {
    if (a.optional !== b.optional) {
        return false;
    }
    if (a.typeAlternatives.length !== b.typeAlternatives.length) {
        return false;
    }
    for (const firstTypes of a.typeAlternatives) {
        let found = false;
        for (const otherTypes of b.typeAlternatives) {
            if (otherTypes.array === firstTypes.array
                && otherTypes.reference === firstTypes.reference
                && otherTypes.types.length === firstTypes.types.length
                && otherTypes.types.every(e => firstTypes.types.includes(e))) {
                found = true;
            }
        }
        if (!found) {
            return false;
        }
    }
    return true;
}
function collectAllSuperProperties(type, mode, resources, map = new collections_1.MultiMap(), visitedTypes = new Set()) {
    if (visitedTypes.has(type.name)) {
        return map;
    }
    visitedTypes.add(type.name);
    const typeProps = type.properties;
    for (const property of typeProps) {
        map.add(property.name, property);
    }
    for (const superType of type.interfaceSuperTypes) {
        const typeInfo = resources.get(superType);
        const type = typeInfo === null || typeInfo === void 0 ? void 0 : typeInfo[mode];
        if (isInterface(type)) {
            collectAllSuperProperties(type, mode, resources, map, visitedTypes);
        }
    }
    return map;
}
function applyErrorToAssignment(nodes, accept) {
    const assignmentNodes = nodes.flatMap(node => (0, internal_grammar_util_1.extractAssignments)(node.definition));
    return (propertyName, errorMessage) => {
        const node = assignmentNodes.find(assignment => assignment.feature === propertyName);
        if (node) {
            accept('error', errorMessage, { node, property: 'feature' });
        }
    };
}
exports.applyErrorToAssignment = applyErrorToAssignment;
function isType(type) {
    return type && 'union' in type;
}
function isInterface(type) {
    return type && 'properties' in type;
}
function isInferredAndDeclared(type) {
    return type && 'inferred' in type && 'declared' in type;
}
function collectValidationResources(grammar) {
    const astResources = (0, types_util_1.collectAllAstResources)([grammar]);
    const inferred = (0, inferred_types_1.collectInferredTypes)(Array.from(astResources.parserRules), Array.from(astResources.datatypeRules));
    const declared = (0, declared_types_1.collectDeclaredTypes)(Array.from(astResources.interfaces), Array.from(astResources.types), inferred);
    const typeNameToRules = getTypeNameToRules(astResources);
    const inferredInfo = mergeTypesAndInterfaces(inferred)
        .reduce((acc, type) => acc.set(type.name, { inferred: type, nodes: typeNameToRules.get(type.name) }), new Map());
    const allTypesInfo = mergeTypesAndInterfaces(declared)
        .reduce((acc, type) => {
        var _a;
        const node = (_a = (0, stream_1.stream)(astResources.types).find(e => e.name === type.name)) !== null && _a !== void 0 ? _a : (0, stream_1.stream)(astResources.interfaces).find(e => e.name === type.name);
        if (node) {
            const inferred = inferredInfo.get(type.name);
            acc.set(type.name, inferred ? Object.assign(Object.assign({}, inferred), { declared: type, node }) : { declared: type, node });
        }
        return acc;
    }, new Map());
    return allTypesInfo;
}
exports.collectValidationResources = collectValidationResources;
function getTypeNameToRules(astResources) {
    return (0, stream_1.stream)(astResources.parserRules)
        .concat(astResources.datatypeRules)
        .reduce((acc, rule) => acc.add((0, internal_grammar_util_1.getRuleType)(rule), rule), new collections_1.MultiMap());
}
function mergeTypesAndInterfaces(astTypes) {
    return astTypes.interfaces.concat(astTypes.unions);
}
const arrRefError = (found, expected) => found.array && !expected.array && found.reference && !expected.reference ? 'can\'t be an array and a reference' :
    !found.array && expected.array && !found.reference && expected.reference ? 'has to be an array and a reference' :
        found.array && !expected.array ? 'can\'t be an array' :
            !found.array && expected.array ? 'has to be an array' :
                found.reference && !expected.reference ? 'can\'t be a reference' :
                    !found.reference && expected.reference ? 'has to be a reference' : '';
function checkAlternativesConsistencyHelper(found, expected) {
    const stringToPropertyTypeList = (propertyTypeList) => propertyTypeList.reduce((acc, e) => acc.set((0, types_util_1.distinctAndSorted)(e.types).join(' | '), e), new Map());
    const stringToFound = stringToPropertyTypeList(found);
    const stringToExpected = stringToPropertyTypeList(expected);
    const errorsInfo = [];
    // detects extra type alternatives & check matched ones on consistency by 'array' and 'reference'
    for (const [typeString, foundPropertyType] of (0, stream_1.stream)(stringToFound)) {
        const expectedPropertyType = stringToExpected.get(typeString);
        if (!expectedPropertyType) {
            errorsInfo.push({ typeString, errorMessage: 'is not expected' });
        }
        else if (expectedPropertyType.array !== foundPropertyType.array || expectedPropertyType.reference !== foundPropertyType.reference) {
            errorsInfo.push({ typeString, errorMessage: arrRefError(foundPropertyType, expectedPropertyType) });
        }
    }
    return errorsInfo;
}
function checkAlternativesConsistency(inferred, declared, errorToRuleNodes) {
    const errorsInfo = checkAlternativesConsistencyHelper(inferred, declared);
    for (const errorInfo of errorsInfo) {
        errorToRuleNodes(`A type '${errorInfo.typeString}' ${errorInfo.errorMessage}`);
    }
}
function checkPropertiesConsistency(inferred, declared, errorToRuleNodes, errorToAssignment, errorToInvalidRuleNodes) {
    const baseError = (propertyName, foundType, expectedType) => `The assigned type '${foundType}' is not compatible with the declared property '${propertyName}' of type '${expectedType}'.`;
    const checkOptional = (found, expected) => !(found.typeAlternatives.length === 1 && found.typeAlternatives[0].array ||
        expected.typeAlternatives.length === 1 && expected.typeAlternatives[0].array);
    // detects extra properties & check matched ones on consistency by 'optional'
    for (const propName of inferred.keys()) {
        const foundProperties = inferred.get(propName);
        const foundProperty = foundProperties[0];
        const expectedProperties = declared.get(propName);
        const expectedProperty = expectedProperties[0];
        if (expectedProperty) {
            const foundStringType = (0, types_util_1.propertyTypeArrayToString)(foundProperty.typeAlternatives);
            const expectedStringType = (0, types_util_1.propertyTypeArrayToString)(expectedProperty.typeAlternatives);
            if (foundStringType !== expectedStringType) {
                const typeAlternativesErrors = checkAlternativesConsistencyHelper(foundProperty.typeAlternatives, expectedProperty.typeAlternatives);
                if (typeAlternativesErrors.length > 0) {
                    let resultError = baseError(foundProperty.name, foundStringType, expectedStringType);
                    for (const errorInfo of typeAlternativesErrors) {
                        resultError = resultError + ` '${errorInfo.typeString}' ${errorInfo.errorMessage};`;
                    }
                    resultError = resultError.replace(/;$/, '.');
                    errorToAssignment(foundProperty.name, resultError);
                }
            }
            if (checkOptional(foundProperty, expectedProperty) && !expectedProperty.optional && foundProperty.optional) {
                errorToInvalidRuleNodes(foundProperty.name, `Property '${foundProperty.name}' is missing`);
            }
        }
        else {
            errorToAssignment(foundProperty.name, `A property '${foundProperty.name}' is not expected.`);
        }
    }
    // detects lack of properties
    for (const [property, expectedProperties] of declared.entriesGroupedByKey()) {
        const foundProperty = inferred.get(property);
        if (foundProperty.length === 0 && !expectedProperties.some(e => e.optional)) {
            errorToRuleNodes(`A property '${property}' is expected`);
        }
    }
}
// use only after type consistancy validation
function collectAllInterfaces(grammar) {
    const astResources = (0, types_util_1.collectAllAstResources)([grammar]);
    const inferred = (0, inferred_types_1.collectInferredTypes)(Array.from(astResources.parserRules), Array.from(astResources.datatypeRules));
    const declared = (0, declared_types_1.collectDeclaredTypes)(Array.from(astResources.interfaces), Array.from(astResources.types), inferred);
    const typeNameToRules = getTypeNameToRules(astResources);
    const inferredInterfaces = inferred.interfaces
        .reduce((acc, type) => acc.set(type.name, { type, node: typeNameToRules.get(type.name) }), new Map());
    return declared.interfaces
        .reduce((acc, type) => {
        if (!acc.has(type.name)) {
            const node = (0, stream_1.stream)(astResources.interfaces).find(e => e.name === type.name);
            if (node)
                acc.set(type.name, { type, node });
        }
        return acc;
    }, inferredInterfaces);
}
exports.collectAllInterfaces = collectAllInterfaces;
//# sourceMappingURL=type-validator.js.map