"use strict";
/******************************************************************************
 * This file was generated by langium-cli 0.4.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.isParserRule = exports.ParserRule = exports.isParameterReference = exports.ParameterReference = exports.isParameter = exports.Parameter = exports.isNegation = exports.Negation = exports.isNegatedToken = exports.NegatedToken = exports.isNamedArgument = exports.NamedArgument = exports.isLiteralCondition = exports.LiteralCondition = exports.isKeyword = exports.Keyword = exports.isInterface = exports.Interface = exports.isInferredType = exports.InferredType = exports.isGroup = exports.Group = exports.isGrammarImport = exports.GrammarImport = exports.isGrammar = exports.Grammar = exports.isDisjunction = exports.Disjunction = exports.isCrossReference = exports.CrossReference = exports.isConjunction = exports.Conjunction = exports.isCharacterRange = exports.CharacterRange = exports.isAtomType = exports.AtomType = exports.isAssignment = exports.Assignment = exports.isAlternatives = exports.Alternatives = exports.isAction = exports.Action = exports.isAbstractElement = exports.AbstractElement = exports.isCondition = exports.Condition = exports.isAbstractType = exports.AbstractType = exports.isAbstractRule = exports.AbstractRule = void 0;
exports.reflection = exports.LangiumGrammarAstReflection = exports.isWildcard = exports.Wildcard = exports.isUntilToken = exports.UntilToken = exports.isUnorderedGroup = exports.UnorderedGroup = exports.isTypeAttribute = exports.TypeAttribute = exports.isType = exports.Type = exports.isTerminalRuleCall = exports.TerminalRuleCall = exports.isTerminalRule = exports.TerminalRule = exports.isTerminalGroup = exports.TerminalGroup = exports.isTerminalAlternatives = exports.TerminalAlternatives = exports.isRuleCall = exports.RuleCall = exports.isReturnType = exports.ReturnType = exports.isRegexToken = exports.RegexToken = void 0;
const ast_util_1 = require("../../utils/ast-util");
exports.AbstractRule = 'AbstractRule';
function isAbstractRule(item) {
    return exports.reflection.isInstance(item, exports.AbstractRule);
}
exports.isAbstractRule = isAbstractRule;
exports.AbstractType = 'AbstractType';
function isAbstractType(item) {
    return exports.reflection.isInstance(item, exports.AbstractType);
}
exports.isAbstractType = isAbstractType;
exports.Condition = 'Condition';
function isCondition(item) {
    return exports.reflection.isInstance(item, exports.Condition);
}
exports.isCondition = isCondition;
exports.AbstractElement = 'AbstractElement';
function isAbstractElement(item) {
    return exports.reflection.isInstance(item, exports.AbstractElement);
}
exports.isAbstractElement = isAbstractElement;
exports.Action = 'Action';
function isAction(item) {
    return exports.reflection.isInstance(item, exports.Action);
}
exports.isAction = isAction;
exports.Alternatives = 'Alternatives';
function isAlternatives(item) {
    return exports.reflection.isInstance(item, exports.Alternatives);
}
exports.isAlternatives = isAlternatives;
exports.Assignment = 'Assignment';
function isAssignment(item) {
    return exports.reflection.isInstance(item, exports.Assignment);
}
exports.isAssignment = isAssignment;
exports.AtomType = 'AtomType';
function isAtomType(item) {
    return exports.reflection.isInstance(item, exports.AtomType);
}
exports.isAtomType = isAtomType;
exports.CharacterRange = 'CharacterRange';
function isCharacterRange(item) {
    return exports.reflection.isInstance(item, exports.CharacterRange);
}
exports.isCharacterRange = isCharacterRange;
exports.Conjunction = 'Conjunction';
function isConjunction(item) {
    return exports.reflection.isInstance(item, exports.Conjunction);
}
exports.isConjunction = isConjunction;
exports.CrossReference = 'CrossReference';
function isCrossReference(item) {
    return exports.reflection.isInstance(item, exports.CrossReference);
}
exports.isCrossReference = isCrossReference;
exports.Disjunction = 'Disjunction';
function isDisjunction(item) {
    return exports.reflection.isInstance(item, exports.Disjunction);
}
exports.isDisjunction = isDisjunction;
exports.Grammar = 'Grammar';
function isGrammar(item) {
    return exports.reflection.isInstance(item, exports.Grammar);
}
exports.isGrammar = isGrammar;
exports.GrammarImport = 'GrammarImport';
function isGrammarImport(item) {
    return exports.reflection.isInstance(item, exports.GrammarImport);
}
exports.isGrammarImport = isGrammarImport;
exports.Group = 'Group';
function isGroup(item) {
    return exports.reflection.isInstance(item, exports.Group);
}
exports.isGroup = isGroup;
exports.InferredType = 'InferredType';
function isInferredType(item) {
    return exports.reflection.isInstance(item, exports.InferredType);
}
exports.isInferredType = isInferredType;
exports.Interface = 'Interface';
function isInterface(item) {
    return exports.reflection.isInstance(item, exports.Interface);
}
exports.isInterface = isInterface;
exports.Keyword = 'Keyword';
function isKeyword(item) {
    return exports.reflection.isInstance(item, exports.Keyword);
}
exports.isKeyword = isKeyword;
exports.LiteralCondition = 'LiteralCondition';
function isLiteralCondition(item) {
    return exports.reflection.isInstance(item, exports.LiteralCondition);
}
exports.isLiteralCondition = isLiteralCondition;
exports.NamedArgument = 'NamedArgument';
function isNamedArgument(item) {
    return exports.reflection.isInstance(item, exports.NamedArgument);
}
exports.isNamedArgument = isNamedArgument;
exports.NegatedToken = 'NegatedToken';
function isNegatedToken(item) {
    return exports.reflection.isInstance(item, exports.NegatedToken);
}
exports.isNegatedToken = isNegatedToken;
exports.Negation = 'Negation';
function isNegation(item) {
    return exports.reflection.isInstance(item, exports.Negation);
}
exports.isNegation = isNegation;
exports.Parameter = 'Parameter';
function isParameter(item) {
    return exports.reflection.isInstance(item, exports.Parameter);
}
exports.isParameter = isParameter;
exports.ParameterReference = 'ParameterReference';
function isParameterReference(item) {
    return exports.reflection.isInstance(item, exports.ParameterReference);
}
exports.isParameterReference = isParameterReference;
exports.ParserRule = 'ParserRule';
function isParserRule(item) {
    return exports.reflection.isInstance(item, exports.ParserRule);
}
exports.isParserRule = isParserRule;
exports.RegexToken = 'RegexToken';
function isRegexToken(item) {
    return exports.reflection.isInstance(item, exports.RegexToken);
}
exports.isRegexToken = isRegexToken;
exports.ReturnType = 'ReturnType';
function isReturnType(item) {
    return exports.reflection.isInstance(item, exports.ReturnType);
}
exports.isReturnType = isReturnType;
exports.RuleCall = 'RuleCall';
function isRuleCall(item) {
    return exports.reflection.isInstance(item, exports.RuleCall);
}
exports.isRuleCall = isRuleCall;
exports.TerminalAlternatives = 'TerminalAlternatives';
function isTerminalAlternatives(item) {
    return exports.reflection.isInstance(item, exports.TerminalAlternatives);
}
exports.isTerminalAlternatives = isTerminalAlternatives;
exports.TerminalGroup = 'TerminalGroup';
function isTerminalGroup(item) {
    return exports.reflection.isInstance(item, exports.TerminalGroup);
}
exports.isTerminalGroup = isTerminalGroup;
exports.TerminalRule = 'TerminalRule';
function isTerminalRule(item) {
    return exports.reflection.isInstance(item, exports.TerminalRule);
}
exports.isTerminalRule = isTerminalRule;
exports.TerminalRuleCall = 'TerminalRuleCall';
function isTerminalRuleCall(item) {
    return exports.reflection.isInstance(item, exports.TerminalRuleCall);
}
exports.isTerminalRuleCall = isTerminalRuleCall;
exports.Type = 'Type';
function isType(item) {
    return exports.reflection.isInstance(item, exports.Type);
}
exports.isType = isType;
exports.TypeAttribute = 'TypeAttribute';
function isTypeAttribute(item) {
    return exports.reflection.isInstance(item, exports.TypeAttribute);
}
exports.isTypeAttribute = isTypeAttribute;
exports.UnorderedGroup = 'UnorderedGroup';
function isUnorderedGroup(item) {
    return exports.reflection.isInstance(item, exports.UnorderedGroup);
}
exports.isUnorderedGroup = isUnorderedGroup;
exports.UntilToken = 'UntilToken';
function isUntilToken(item) {
    return exports.reflection.isInstance(item, exports.UntilToken);
}
exports.isUntilToken = isUntilToken;
exports.Wildcard = 'Wildcard';
function isWildcard(item) {
    return exports.reflection.isInstance(item, exports.Wildcard);
}
exports.isWildcard = isWildcard;
class LangiumGrammarAstReflection {
    getAllTypes() {
        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'Assignment', 'AtomType', 'CharacterRange', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'Grammar', 'GrammarImport', 'Group', 'InferredType', 'Interface', 'Keyword', 'LiteralCondition', 'NamedArgument', 'NegatedToken', 'Negation', 'Parameter', 'ParameterReference', 'ParserRule', 'RegexToken', 'ReturnType', 'RuleCall', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'UnorderedGroup', 'UntilToken', 'Wildcard'];
    }
    isInstance(node, type) {
        return (0, ast_util_1.isAstNode)(node) && this.isSubtype(node.$type, type);
    }
    isSubtype(subtype, supertype) {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case exports.Action: {
                return this.isSubtype(exports.AbstractElement, supertype) || this.isSubtype(exports.AbstractType, supertype);
            }
            case exports.Alternatives:
            case exports.Assignment:
            case exports.CharacterRange:
            case exports.CrossReference:
            case exports.Group:
            case exports.Keyword:
            case exports.NegatedToken:
            case exports.RegexToken:
            case exports.RuleCall:
            case exports.TerminalAlternatives:
            case exports.TerminalGroup:
            case exports.TerminalRuleCall:
            case exports.UnorderedGroup:
            case exports.UntilToken:
            case exports.Wildcard: {
                return this.isSubtype(exports.AbstractElement, supertype);
            }
            case exports.Conjunction:
            case exports.Disjunction:
            case exports.LiteralCondition:
            case exports.Negation:
            case exports.ParameterReference: {
                return this.isSubtype(exports.Condition, supertype);
            }
            case exports.Interface:
            case exports.Type: {
                return this.isSubtype(exports.AbstractType, supertype);
            }
            case exports.ParserRule: {
                return this.isSubtype(exports.AbstractRule, supertype) || this.isSubtype(exports.AbstractType, supertype);
            }
            case exports.TerminalRule: {
                return this.isSubtype(exports.AbstractRule, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:type': {
                return exports.AbstractType;
            }
            case 'AtomType:refType': {
                return exports.AbstractType;
            }
            case 'CrossReference:type': {
                return exports.AbstractType;
            }
            case 'Grammar:hiddenTokens': {
                return exports.AbstractRule;
            }
            case 'Grammar:usedGrammars': {
                return exports.Grammar;
            }
            case 'Interface:superTypes': {
                return exports.AbstractType;
            }
            case 'NamedArgument:parameter': {
                return exports.Parameter;
            }
            case 'ParameterReference:parameter': {
                return exports.Parameter;
            }
            case 'ParserRule:hiddenTokens': {
                return exports.AbstractRule;
            }
            case 'ParserRule:returnType': {
                return exports.AbstractType;
            }
            case 'RuleCall:rule': {
                return exports.AbstractRule;
            }
            case 'TerminalRuleCall:rule': {
                return exports.TerminalRule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case 'Alternatives': {
                return {
                    name: 'Alternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'AtomType': {
                return {
                    name: 'AtomType',
                    mandatory: [
                        { name: 'isArray', type: 'boolean' },
                        { name: 'isRef', type: 'boolean' }
                    ]
                };
            }
            case 'CrossReference': {
                return {
                    name: 'CrossReference',
                    mandatory: [
                        { name: 'deprecatedSyntax', type: 'boolean' }
                    ]
                };
            }
            case 'Grammar': {
                return {
                    name: 'Grammar',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'imports', type: 'array' },
                        { name: 'interfaces', type: 'array' },
                        { name: 'isDeclared', type: 'boolean' },
                        { name: 'rules', type: 'array' },
                        { name: 'types', type: 'array' },
                        { name: 'usedGrammars', type: 'array' }
                    ]
                };
            }
            case 'Group': {
                return {
                    name: 'Group',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'Interface': {
                return {
                    name: 'Interface',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'superTypes', type: 'array' }
                    ]
                };
            }
            case 'LiteralCondition': {
                return {
                    name: 'LiteralCondition',
                    mandatory: [
                        { name: 'true', type: 'boolean' }
                    ]
                };
            }
            case 'NamedArgument': {
                return {
                    name: 'NamedArgument',
                    mandatory: [
                        { name: 'calledByName', type: 'boolean' }
                    ]
                };
            }
            case 'ParserRule': {
                return {
                    name: 'ParserRule',
                    mandatory: [
                        { name: 'definesHiddenTokens', type: 'boolean' },
                        { name: 'entry', type: 'boolean' },
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hiddenTokens', type: 'array' },
                        { name: 'parameters', type: 'array' },
                        { name: 'wildcard', type: 'boolean' }
                    ]
                };
            }
            case 'RuleCall': {
                return {
                    name: 'RuleCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'TerminalAlternatives': {
                return {
                    name: 'TerminalAlternatives',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'TerminalGroup': {
                return {
                    name: 'TerminalGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'TerminalRule': {
                return {
                    name: 'TerminalRule',
                    mandatory: [
                        { name: 'fragment', type: 'boolean' },
                        { name: 'hidden', type: 'boolean' }
                    ]
                };
            }
            case 'Type': {
                return {
                    name: 'Type',
                    mandatory: [
                        { name: 'typeAlternatives', type: 'array' }
                    ]
                };
            }
            case 'TypeAttribute': {
                return {
                    name: 'TypeAttribute',
                    mandatory: [
                        { name: 'isOptional', type: 'boolean' },
                        { name: 'typeAlternatives', type: 'array' }
                    ]
                };
            }
            case 'UnorderedGroup': {
                return {
                    name: 'UnorderedGroup',
                    mandatory: [
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}
exports.LangiumGrammarAstReflection = LangiumGrammarAstReflection;
exports.reflection = new LangiumGrammarAstReflection();
//# sourceMappingURL=ast.js.map