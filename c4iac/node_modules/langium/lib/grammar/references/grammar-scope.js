"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarScopeComputation = exports.LangiumGrammarScopeProvider = void 0;
const scope_computation_1 = require("../../references/scope-computation");
const scope_provider_1 = require("../../references/scope-provider");
const ast_util_1 = require("../../utils/ast-util");
const stream_1 = require("../../utils/stream");
const ast_1 = require("../generated/ast");
const internal_grammar_util_1 = require("../internal-grammar-util");
class LangiumGrammarScopeProvider extends scope_provider_1.DefaultScopeProvider {
    constructor(services) {
        super(services);
    }
    getScope(context) {
        const referenceType = this.reflection.getReferenceType(context);
        if (referenceType !== 'AbstractType')
            return super.getScope(context);
        const scopes = [];
        const precomputed = (0, ast_util_1.getDocument)(context.container).precomputedScopes;
        const rootNode = (0, ast_util_1.findRootNode)(context.container);
        if (precomputed && rootNode) {
            const allDescriptions = precomputed.get(rootNode);
            const parserRuleScopesArray = [];
            const scopesArray = [];
            if (allDescriptions.length > 0) {
                for (const description of allDescriptions) {
                    if (this.reflection.isSubtype(description.type, 'ParserRule')) {
                        parserRuleScopesArray.push(description);
                    }
                    else if (this.reflection.isSubtype(description.type, referenceType)) {
                        scopesArray.push(description);
                    }
                }
                scopes.push((0, stream_1.stream)(scopesArray.concat(parserRuleScopesArray.filter(parserRule => !scopesArray.some(e => e.name === parserRule.name)))));
            }
        }
        let result = this.getGlobalScope(referenceType);
        for (let i = scopes.length - 1; i >= 0; i--) {
            result = this.createScope(scopes[i], result);
        }
        return result;
    }
}
exports.LangiumGrammarScopeProvider = LangiumGrammarScopeProvider;
class LangiumGrammarScopeComputation extends scope_computation_1.DefaultScopeComputation {
    constructor(services) {
        super(services);
        this.processTypeNode = (0, internal_grammar_util_1.processTypeNodeWithNodeLocator)(services.workspace.AstNodeLocator);
        this.processActionNode = (0, internal_grammar_util_1.processActionNodeWithNodeDescriptionProvider)(services.workspace.AstNodeDescriptionProvider);
    }
    processNode(node, document, scopes) {
        if ((0, ast_1.isReturnType)(node))
            return;
        this.processTypeNode(node, document, scopes);
        this.processActionNode(node, document, scopes);
        super.processNode(node, document, scopes);
    }
}
exports.LangiumGrammarScopeComputation = LangiumGrammarScopeComputation;
//# sourceMappingURL=grammar-scope.js.map