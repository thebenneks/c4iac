"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.interpretAstReflection = void 0;
const ast_util_1 = require("../utils/ast-util");
const collections_1 = require("../utils/collections");
const file_system_provider_1 = require("../workspace/file-system-provider");
const ast_1 = require("./generated/ast");
const langium_grammar_module_1 = require("./langium-grammar-module");
const type_collector_1 = require("./type-system/type-collector");
const types_util_1 = require("./type-system/types-util");
let emptyDocuments;
function interpretAstReflection(grammarOrTypes, documents) {
    let collectedTypes;
    if ((0, ast_1.isGrammar)(grammarOrTypes)) {
        if (!emptyDocuments && !documents) {
            emptyDocuments = (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).shared.workspace.LangiumDocuments;
        }
        collectedTypes = (0, type_collector_1.collectAst)(documents !== null && documents !== void 0 ? documents : emptyDocuments, [grammarOrTypes]);
    }
    else {
        collectedTypes = grammarOrTypes;
    }
    const allTypes = collectedTypes.interfaces.map(e => e.name).concat(collectedTypes.unions.map(e => e.name));
    const references = buildReferenceTypes(collectedTypes);
    const metaData = buildTypeMetaData(collectedTypes);
    const superTypeMap = buildSupertypeMap(collectedTypes);
    return {
        getAllTypes() {
            return allTypes;
        },
        getReferenceType(refInfo) {
            const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
            const referenceType = references.get(referenceId);
            if (referenceType) {
                return referenceType;
            }
            throw new Error('Could not find reference type for ' + referenceId);
        },
        getTypeMetaData(type) {
            var _a;
            return (_a = metaData.get(type)) !== null && _a !== void 0 ? _a : {
                name: type,
                mandatory: []
            };
        },
        isInstance(node, type) {
            return (0, ast_util_1.isAstNode)(node) && this.isSubtype(node.$type, type);
        },
        isSubtype(subtype, originalSuperType) {
            if (subtype === originalSuperType) {
                return true;
            }
            const superTypes = superTypeMap.get(subtype);
            for (const superType of superTypes) {
                if (this.isSubtype(superType, originalSuperType)) {
                    return true;
                }
            }
            return false;
        }
    };
}
exports.interpretAstReflection = interpretAstReflection;
function buildReferenceTypes(astTypes) {
    const references = new Map();
    for (const interfaceType of astTypes.interfaces) {
        for (const property of interfaceType.properties) {
            for (const propertyAlternative of property.typeAlternatives) {
                if (propertyAlternative.reference) {
                    references.set(`${interfaceType.name}:${property.name}`, propertyAlternative.types[0]);
                }
            }
        }
    }
    return references;
}
function buildTypeMetaData(astTypes) {
    const map = new Map();
    const allProperties = (0, types_util_1.collectAllProperties)(astTypes.interfaces);
    for (const interfaceType of astTypes.interfaces) {
        const props = allProperties.get(interfaceType.name);
        const arrayProps = props.filter(e => e.typeAlternatives.some(e => e.array));
        const booleanProps = props.filter(e => e.typeAlternatives.every(e => !e.array && e.types.includes('boolean')));
        if (arrayProps.length > 0 || booleanProps.length > 0) {
            map.set(interfaceType.name, {
                name: interfaceType.name,
                mandatory: buildMandatoryMetaData(arrayProps, booleanProps)
            });
        }
    }
    return map;
}
function buildMandatoryMetaData(arrayProps, booleanProps) {
    const array = [];
    const all = arrayProps.concat(booleanProps).sort((a, b) => a.name.localeCompare(b.name));
    for (const property of all) {
        const type = arrayProps.includes(property) ? 'array' : 'boolean';
        array.push({
            name: property.name,
            type
        });
    }
    return array;
}
function buildSupertypeMap(astTypes) {
    const map = new collections_1.MultiMap();
    for (const interfaceType of astTypes.interfaces) {
        map.addAll(interfaceType.name, interfaceType.superTypes);
    }
    for (const unionType of astTypes.unions) {
        map.addAll(unionType.name, unionType.superTypes);
    }
    return map;
}
//# sourceMappingURL=ast-reflection-interpreter.js.map